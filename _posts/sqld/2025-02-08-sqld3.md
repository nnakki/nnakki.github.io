---
title: "[SQLD]성능 데이터 모델링과 정규화"
excerpt: "성능 데이터 모델링, 정규화, 반정규화"

categories:
  - qualifications
tags: # 포스트 태그
  - [SQLD] 

permalink: /sqld/basic/

date: 2025-02-08 # 작성 날짜
---

### 성능 데이터 모델링과 정규화

>  **데이터베이스 성능 향상을 목적으로 하는 작업을 의미**<br>데이터베이스는 우리가 생각하는 것보다 훨씬 더 많은 요청을 처리함. 내부적으로 수많은 과정을 거쳐야 하는 경우도 있고, 어쩌다 한 번 수행되는 구문은 그 순간에만 조금 비효율적인 결과에 대한 비용을 지불하면 되지만, 매우 빠른 템포로 자주 발생하는 쿼리문이 비효율적이면 DB 전체 성능에 치명적인 영향을 끼치기도 한다. 

- 성능 향상이 목적이기 때문에 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 데이터분할, 조인구조, PK, FK 등 여러가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것

#### 성능 데이터 모델링 수행시점

프로젝트 수행 중보다는 사전에 철저하게 설계 된 상태로 도입할 수록 비용이 적게 든다.<br>데이터베이스 분석 및 설계 단계에서 처리 성능을 향상 시키기 위한 준비를 많이 해야한다. 어떠한 트랜젝션이 비즈니스 로직의 핵심인지 파악하고 사용자 업무 처리에 중요성을 보이는지 분석해야한다. 취약점이라고 생각되는 부분에 트랜잭션을 발생시켜 실제 성능을 테스트 해보는 것도 필요한 작업이다.

`트랜잭션` : 데이터베이스의 <u>상태를 변화시키기 위해 수행하는 작업 단위</u>

#### 성능 데이터 모델의 고려사항

- **정규화를 정확하게 수행**<br>
  데이터를 주요 관심사별로 분산시킬 수 있으므로 자체로 성능향상 효과 기대
- **데이터베이스 용량 산정 수행**<br>어떤 테이블에 데이터가 집중되는지 파악 가능
- **데이터베이스에서 발생되는 트랜잭션 유형 파악**<br>CRUD 매트릭스 혹은 시퀀스 다이어그램을 보면서 파악, 데이터 조회에 필요한 조인관계파악가능
- **데이터베이스의 용량과 트랜잭션 유형에 따라 반정규화 수행**<br>테이블, 속성, 관계 등에 대해서 포괄적인 반정규화를 통해 성능 조정
- **이력 모델, PK, FK, 슈퍼타입/서브타입 조정**
- **성능 관점에서 데이터 모델 검증**

### <span style="color:red">정규화</span> 이론

> **정규화**<br>데이터에 대한 중복성을 제거하여 성능을 향상시키는 것을 의미한다. 특정한 칼럼으로 분산되어 있는 데이터의 의미를 하나로 집약시킬 수 있기 때문에 테이블의 칼럼 수가 줄어들어 데이터 용량을 줄일 수 있다.<br>조회하고자 하는 데이터가 여러 테이블에 분산되어 있지 않으면 조회 시 성능이 떨어진다.

1. 정규화 (Normalization) 
   - DBMS 테이블의 삽입, 삭제, 수정 과정에서 이상 현상의 발생을 최소화하기 위해 작은 단위의 테이블로 나눠가는 과정
2. 정규형 (NF : Normal Form)
   - 정규화에 의해 도출된 데이터 모델이 갖춰야 할 특성을 만족하는 정규화 된 결과물
3. 함수적 종속성(FD : Functional Dependency) 
   - 칼럼 A를 알고 있으면 B를 알수 있고, A가 변화하면 B도 변한다고 할 때, B는 A에 대해 함수적 종속성을 갖는다고 표현한다.
4. 결정자 : 함수적 종속성을 결정짓는 요소, 종속성에서의 칼럼 A
5. 다치종속 
   - 결정자 컬럼 A에 의해 칼럼 B의 값을 다수 알 수 있을 때, B는 A에 다치종속 되었다고 표현함.

#### 정규화의 이점

1. 데이터의 유연성 : 종속성이 강한 데이터를 분리하여 독립된 개념으로 정의하기 때문에 높은 응집도와 낮은 결합도 원칙에 충실해진다.
2. 데이터의 재활용성 
3. 데이터의 중복 최소화

#### 정규화 이론

1. 제1정규화 (1NF) 

   - 한 속성에 여러 개의 속성이 포함되어 있거나 같은 유형의 속성이 여러 개로 나눠져있는 경우 해당 속성을 분리<br>= 중복되는 속성값을 한 테이블에(칼럼에) 넣지마! / 하나의 칼럼이 여러 속성값을 갖는다면, 이를 여러 테이블로 분리

2. 제2정규화

   - 제1정규화를 만족시키고 PK가 아닌 모든 컬럼은 PK 전체에 종속<br>= PK에 종속되지 않거나 PK 중 일부의 칼럼에만 종속되는 칼럼이 있다면 분리한다.

   - 갱신이상 현상을 방지하고자함 

     > **갱신 이상 (Modification Anomaly)**<br>반복되는 데이터 중에서 일부를 갱신할 때 데이터가 일치하지 않는 문제를 의미한다. 특정한 값을 갖는 행을 수정할 경우 해당 값을 공유하는 모든 행을 변경해주지 않으면 업데이트 된 내용이 일치하지 않을 수 있다.

3. 제3정규화

   - 제2정규화를 만족시키고 일반 속성간에도 함수 종속 관계가 존재하지 않아야한다.<br>= 종속성을 띄는 일반속성이 있다면 다른 테이블로 분리한다.
     ![image-20250301190344304]({{site.url}}/images/2025-02-08-sqld3/image-20250301190344304.png)

### 반정규화 개념과 설명

> 데이터 중복을 통해 성능 향상이라는 목적을 달성한다. / 읽기(조회) 성능의 향상을 기대<br>데이터무결성의 측면에서 바라보면 반정규화는 있어서는 안 될 일이지만 그럼에도 데이터를 중복하여 반정규화하는데에는 다음과 같은 이유가 있다.
>
> 1. 데이터 조회시, 디스크 I/O량이 많아서 성능이 저하되는 경우 
> 2. 테이블 간 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되는 경우
> 3. 칼럼을 계산하여 읽을 때 저하될 것이라고 예상하는 경우

#### 반정규화 절차
 ![image-20250301191026116]({{site.url}}/images/2025-02-08-sqld3/image-20250301191026116.png)

#### 테이블 반정규화

1. **테이블 병합**
   - 여러개의 테이블을 하나로 합침. 데이터를 중복 저장하게 되지만 조회의 성능 향상을 기대.
2. **테이블 분할**
   - 특정 테이블을 여러개의 테이블로 나누는 것을 의미한다.
     - 수직분할 : 컬럼 기준 분할 / 유독 수정이 많이 일어나는 컬럼을 구태여 분할 <br>ex) abcde 가 있엇는데, b만 유독 수정이 많은 경우 ab / acde 로 2개의 테이블로 분할
     - 수평분할 : 행 기준 분할 / ex) 날짜를 기준으로 칼럼은 동일하지만 10년 전 / 10년 후 분할
3. **테이블 추가**
   - 특정 테이블 추가 / ex) 아예 중복된 테이블을 추가한다거나<br>서버가 다른곳에 있는 테이블이, 다른 서버에서 계속 조회되는 경우 해당 서버에도 테이블추가

#### 칼럼 반정규화

1. **중복컬럼추가**
   - 조인 연산으로 인한 성능 저하를 방지하기 위해 중복 칼럼을 추가하여 조인을 수행하지 않도록 함.
2. **파생컬럼추가**
   - 트랜잭션이 처리되는 시점에 계산하는 값을 미리 계산할 칼럼을 따로 추가
3. **이력컬럼추가**
   - 많은 데이터를 처리할 때 불특정한 날에 대한 조회나 최근 값을 조회할 때 나타날 수 있는 성능 저하방지를 위해 이력테이블에 컬럼을 추가 <br>ex)시작 & 종료 일자 등에 대한 칼럼을 따로 지정

#### 관계 반정규화

1. **중복관계추가** 
   - 여러 경로에 걸쳐 테이블 조인을 하는 경우 조인 연산 자체를 줄여서 조회 성능을 향상시키는 방법<br>만약 A > B > C > D 형태로 테이블 조인이 발생한다면 A > D 가 되도록 줄이는 것
